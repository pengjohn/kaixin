/*!
* \file	 KaiXinAPICommon.cpp
* \author	 GoZone
* \date	
* \brief  开心网应用的框架，处理文件下载、缓存等
*
* \ref    CopyRight
* =======================================================================<br>
*          Copyright ? 2010-2012 GOZONE <br>
*                All Rights Reserved.<br>
* The file is generated by Kaixin_Component Wizard for Tranzda Mobile Platform <br>
* =======================================================================<br>
*/
#include "KaiXinAPI.h"
#include "KaiXinAPICommon.h"
#include  "TDownload.h"
#include "TFileDownloadMrg.h"


#include "TCOM_FileBrowser_Interface.h"
//#include "TCOM_FileBrowser_IIDs.h"     // 此头文件整个项目中仅能包含一次
#include "TCOM_DigitalCamera_DataType.h"
//#include "TCOM_DigitalCamera_IIDs.h"
#include "ImageToolKit/IT_ImageSaver.h"
#include "ssHwSdCard.h"

TFileDownloadMgr*  g_pFileDown = NULL;		//下载管理
IDownLoad *		g_pDownload = NULL;		//文件下载

TFileDownloadMgr*  g_pFileDownEx = NULL;		//下载管理
IDownLoad *		g_pDownloadEx = NULL;		//文件下载
TUChar         		g_PostFilePath[EOS_FILE_MAX_PATH];	//上传图片的路径


/**API 下载接口
* 参数: 
*	accessType: API类型
* 	in_nHwndId: 窗口Id
*	in_nCtrlId: 控件Id
* 	in_nParam: 参数
* 返回值:
*	eSucceed -- 成功
*	eFailed --失败
*
*/
int KaiXinAPICommon_Download(Kx_AccessType  accessType, Int32 in_nHwndId, Int32 in_nCtrlId, Int32 in_nParam)
{
	DownloadError eErr = ERR_NONE;
	char* FilePath = NULL;


	FilePath = KX_GetFileName(accessType);
	if(FilePath == NULL)
		return eFailed;

	TUChar pszFilePath[EOS_FILE_MAX_PATH];
	TUChar pszTemp[EOS_FILE_MAX_FNAME];
//	TUString::StrCopy(pszFilePath,EOS_GetSpecialPath(EOS_FILE_SPECIAL_PATH_LOCAL_DATA));
//	TUString::StrGBToUnicode(pszTemp,(Char*)KAIXIN_FOLDER);
//	TUString::StrCat(pszFilePath,pszTemp);
	SS_GetApplicationPath(AppName_App_KaiXin, SS_APP_PATH_TYPE_CACHE, pszFilePath);
	
	TUString::StrGBToUnicode(pszTemp,(Char*)FilePath);
	TUString::StrCat(pszFilePath,pszTemp);

	if (EOS_IsFileExist(pszFilePath))
		EOS_Delete(pszFilePath);

	char* pURL = NULL;

	//uid/verify赋值(除了KX_Initial_Login)
	if(KX_InitialLogin != accessType)
	{
		Set_Url_Params(accessType, "uid", (char*)KaiXinUserInfo.uid);
		Set_Url_Params(accessType, "verify", (char*)KaiXinUserInfo.verify);
	}

	Url_Generate(accessType, &pURL);


	if(pURL!=NULL && *pURL != 0)
	{
		TAListElement  pElement;
		MemSet(&pElement, 0, sizeof(TAListElement));

		pElement.accessType = accessType;
		STRCPY_Ex(pElement.pURL,pURL);
		pElement.nHwndId = in_nHwndId;
		pElement.nCtrlId = in_nCtrlId;
		pElement.nParam = in_nParam;
		TUString::StrCopy(pElement.pszFilePath, pszFilePath);

		//添加到下载管理并启动下载
		Boolean bNeedWaitingBox = FALSE;
		bNeedWaitingBox = GetApiNeedWaitingBox((Kx_AccessType)accessType);
		if(bNeedWaitingBox == TRUE)
		{
			g_pFileDown->Add(&pElement);
			g_pFileDown->DownLoadStart();

			//API json下载时显示等待提示框
			{
				SS_GTID		gtidMain;
				NotifyMsgDataType notifyData;
				MemSet(&notifyData, 0, sizeof(NotifyMsgDataType));
				SS_GetCurrentGTID(&gtidMain);
				notifyData.nAccessType  = accessType;
				App_PostMessageEx(&gtidMain, MSG_DL_THREAD_START, &notifyData, sizeof(NotifyMsgDataType), in_nHwndId, in_nCtrlId);
			}
		}
		else
		{
			g_pFileDown->Add(&pElement);
			g_pFileDown->DownLoadStart();
		}	

	}
	free(pURL);
	return eSucceed;

}	

/**图片 下载接口
* 参数: 
*	accessType: API类型
* 	in_nHwndId: 窗口Id
* 	in_nParam: 参数
* 返回值:
*	eSucceed -- 成功
*	eFailed --失败
*
*/
int KaiXinAPICommon_DownloadPhoto(char* pURL, Int32 in_nHwndId,Int32 in_nParam )
{
	if(KaiXinUserInfo.bLoadImage == FALSE)
		return eSucceed;

	if(pURL!=NULL && *pURL != 0)
	{
		TUChar* pszFilePath = NULL;
		pszFilePath = FilePathFromUrl(pURL);

		if(pszFilePath != NULL)
		{
			TAListElement  pElement;
			MemSet(&pElement, 0, sizeof(TAListElement));
			pElement.accessType = KX_PhotoDownload;
			STRCPY_Ex(pElement.pURL,pURL);
			pElement.nHwndId = in_nHwndId;
			pElement.nCtrlId = 0;
			pElement.nParam = in_nParam;		
			TUString::StrCopy(pElement.pszFilePath, pszFilePath);
			free(pszFilePath);

			g_pFileDown->Insert(&pElement, 0);
			g_pFileDown->DownLoadStart();
		}
	}
	return eSucceed;
}


/**图片 上传接口
* 参数: 
*	pszFilePath: 文件路径
*	pszTitle: 显示标题
* 	in_nHwndId: 窗口Id
* 返回值:
*	eSucceed -- 成功
*	eFailed --失败
*
*/
int KaiXinAPICommon_PostPhoto(const TUChar* pszFilePath, const TUChar* pszTitle, Int32 in_nHwndId)
{
	Char pszFileNameString[EOS_FILE_MAX_FNAME];
	TUString::StrCopy(g_PostFilePath, pszFilePath);

	if(EOS_IsFileExist(pszFilePath) == FALSE)
		return eFailed;

	if(pszTitle == NULL)
	{
		TUChar FileName[EOS_FILE_MAX_FNAME];
		EOS_ParsePath(NULL, FileName, NULL, pszFilePath);
		TUString::StrUnicodeToStrUtf8( pszFileNameString, FileName);
		//strcpy((char*)pszFileNameString, "Photo");
	}
	else
	{
		TUString::StrUnicodeToStrUtf8( pszFileNameString, pszTitle);
	}


	Set_Url_Params(KX_UploadPhoto, "title", (char*)pszFileNameString);
	KaiXinAPICommon_Download(KX_UploadPhoto, in_nHwndId);

	return eSucceed;
}


/**
 * 取消所有同AccessType的下载任务
 *
 * \param accessType
 *
 * \return 
 */
int KaiXinAPICommon_DownloadCancelByAccessType(Kx_AccessType  accessType)
{
	g_pFileDown->CancelByAccessType(accessType);
	g_pFileDownEx->CancelByAccessType(accessType);
	return eSucceed;
}

/**
 * 取消所有同HwndId的下载任务 
 *
 * \param nHwndId
 *
 * \return 
 */
int KaiXinAPICommon_DownloadCancelByHwndId(Int32 nHwndId)
{
	g_pFileDown->CancelByHwndId(nHwndId);
	g_pFileDownEx->CancelByHwndId(nHwndId);
	return eSucceed;
}

/**
 * 取消所有下载 
 *
 * \return 
 */
int KaiXinAPICommon_DownloadCancelAll(void)
{
	g_pFileDown->CancelAll();
	g_pFileDownEx->CancelAll();
	return eSucceed;
}

/**
 * 下载完成 
 *
 * \param pElement
 *
 * \return 
 */
int KaiXinAPICommon_DownloadComplete(TAListElement*  pElement)
{
	g_pFileDown->DownLoadComplete(pElement);
	g_pFileDownEx->DownLoadComplete(pElement);
	return eSucceed;
}

/** 下载接口
* 参数: 
*	in_nAccessType: API类型
*	pURL: 下载Url
*	pszFilePath: 保存的文件路径
* 	in_nHwndId: 窗口Id
*	in_nCtrlId: 控件Id
* 	in_nParam: 参数
* 返回值:
*	eSucceed -- 成功
*	eFailed --失败
*
*/
int KaiXinAPI_Download(Int32 in_nAccessType, char* pURL, const TUChar* pszFilePath, Int32 in_nHwndId, Int32 in_nCtrlId, Int32 in_nParam)
{
	DownloadError eErr = ERR_NONE;
	char* FilePath = NULL;

	if( (pURL == NULL) || *pURL ==0 )
		return eFailed;


	//TODO:: 如果文件存在, 则判断时间 or 大小or else (待定), 以决定是否需要重新下载
	if (EOS_IsFileExist(pszFilePath))
	{
		//EOS_Delete(pszFilePath);
		NotifyMsgDataType notifyData;
		MemSet(&notifyData, 0, sizeof(NotifyMsgDataType));

		SS_GTID			gtidMain;
		SS_GetCurrentGTID(&gtidMain);
		notifyData.eDLCode     = DLC_FINISHED;
		notifyData.nAccessType  = in_nAccessType;
		notifyData.nHwndId = in_nHwndId;
		notifyData.nCtrlId = in_nCtrlId;
		notifyData.nParam = in_nParam;
		notifyData.pThisHandle = NULL;
		TUString::StrCopy(notifyData.pszFilePath, pszFilePath);
		App_PostMessageEx(&gtidMain, MSG_DL_THREAD_NOTIFY, &notifyData, sizeof(NotifyMsgDataType), in_nHwndId, in_nCtrlId);
		return eSucceed;
	}

	//Upload Photo使用POST方式
	if(in_nAccessType == KX_UploadPhoto)
		eErr = g_pDownload->DownloadStart(pURL, pszFilePath, in_nAccessType, in_nHwndId, in_nCtrlId, in_nParam, 60,  TRUE, NULL, TRUE);
	else
	{
		Boolean bNeedWaitingBox = FALSE;
		bNeedWaitingBox = GetApiNeedWaitingBox((Kx_AccessType)in_nAccessType);
		//如果不需要等待框的API下载超时为10秒,普通的API下载超时为30秒
		if(bNeedWaitingBox == TRUE)
			eErr = g_pDownload->DownloadStart(pURL, pszFilePath, in_nAccessType, in_nHwndId, in_nCtrlId, in_nParam, 30,  TRUE, NULL, FALSE);
		else
			eErr = g_pDownload->DownloadStart(pURL, pszFilePath, in_nAccessType, in_nHwndId, in_nCtrlId, in_nParam, 10,  TRUE, NULL, FALSE);

		//pengjohn debug, 将url保存下来
		if(in_nAccessType != KX_PhotoDownload)
		{
			int iRet = eFailed;
			Handle hFile = NULL;		
			TUChar pszTempPath[EOS_FILE_MAX_PATH] ={0};
			TUChar* pszTempPath1 = NULL;

			TUString::StrNCopy(pszTempPath, pszFilePath, EOS_FILE_MAX_PATH);
			pszTempPath1 = TUString::StrRChr(pszTempPath, 0x002e);	//'.'
			pszTempPath1[1] = 0x0074;	//'t'
			pszTempPath1[2] = 0x0078;	//'x'	
			pszTempPath1[3] = 0x0074;	//'t'

			if (EOS_IsFileExist(pszTempPath))
				EOS_Delete(pszTempPath);

			hFile = EOS_Open(pszTempPath, PO_TRUNC|PO_BINARY|PO_CREAT|PO_RDWR, PS_IWRITE);
			if (hFile < 0)
			{
				return eFailed;
			}	                    		

			EOS_Write(hFile, (void*)pURL, strlen(pURL)*sizeof(char));
			EOS_Close(hFile);

			char logTxt[128+20] = {0};
			sprintf(logTxt, "[DL Start:%2d]",in_nAccessType);
			strcat(logTxt, KX_GetFileName((Kx_AccessType)in_nAccessType));
			KaiXin_Log(logTxt);
		}
	}

	if( eErr  != ERR_NONE)
	{
		//清除下载列表中的数据(判断条件:accessType/nHwndId/nCtrlId/nParam 全匹配)
		TAListElement  pElement;
		MemSet(&pElement, 0, sizeof(TAListElement));
		pElement.accessType = in_nAccessType;
		pElement.nHwndId = in_nHwndId;
		pElement.nCtrlId = in_nCtrlId;
		pElement.nParam = in_nParam;
		KaiXinAPICommon_DownloadComplete(&pElement);		
		return eFailed;
	}

#if 0
	//API json下载时显示等待提示框
	if(in_nAccessType != KX_PhotoDownload)
	{
		SS_GTID		gtidMain;
		NotifyMsgDataType notifyData;
		MemSet(&notifyData, 0, sizeof(NotifyMsgDataType));
		SS_GetCurrentGTID(&gtidMain);
		notifyData.nAccessType  = in_nAccessType;
		App_PostMessageEx(&gtidMain, MSG_DL_THREAD_START, &notifyData, sizeof(NotifyMsgDataType), in_nHwndId, in_nCtrlId);
	}
#endif
	return eSucceed;

}



/**
 * 创建上传图片PopBox
 *
 * \param pApp
 * \param nHwndId
 *
 * \return 
 */
Int32 PopBox_UploadPhoto(TApplication* pApp, Int32 nHwndId)
{
	//先检测T卡是否可用
	if(EOS_FileIsInAvailabilityPath( EOS_GetSpecialPath(EOS_FILE_SPECIAL_PATH_CARD) ) <= 0)
	{
		Int32 nSDCardState = SDCard_GetCardState();

		if( (nSDCardState == TG3_CARD_STATE_EXIST_OK) && (UsbMgr_GetCurrentFunction() == TG3_USB_FUNCTION_USBDISK))
		{
			pApp->MessageBox(TResource::LoadConstString(APP_KA_ID_STRING_UDiskMode),TResource::LoadConstString(APP_KA_ID_STRING_Info),WMB_OK);
			//T卡当U盘			
		}
		else if(nSDCardState == TG3_CARD_STATE_NOEXIST)
		{
			//没有T卡
			pApp->MessageBox(TResource::LoadConstString(APP_KA_ID_STRING_SDNotReady),TResource::LoadConstString(APP_KA_ID_STRING_Info),WMB_OK);
		}
		else
		{
			//未知错误
			pApp->MessageBox(TResource::LoadConstString(APP_KA_ID_STRING_SDNotReady),TResource::LoadConstString(APP_KA_ID_STRING_Info),WMB_OK);
		}
		
		return -1;
	}


	Int32  nRetPopBoxID = 0;
	TPopupBox	*pPopBox = new TPopupBox(pApp, TResource::LoadConstString(APP_KA_ID_STRING_Cancel), NULL);
	pPopBox->AddItem (1, TResource::LoadConstString(APP_KA_ID_STRING_TakePhoneAndSend), TG3_POPUPBOX_ITEM_TYPE_NORMAL);
	pPopBox->AddItem (2, TResource::LoadConstString(APP_KA_ID_STRING_SelectPhotoAndSend), TG3_POPUPBOX_ITEM_TYPE_NORMAL);
	nRetPopBoxID = pPopBox->Popup();
	delete pPopBox;
	pPopBox = NULL;
	
	//Take Photo
	if(nRetPopBoxID == 1)
	{
		//判断T卡空间是否足够, >4096KByte
		Int32 nSectorsPerClusterP = 0;
		Int32 nBytesPerSectorP = 0;
		Int32 nNumberOfFreeClustersP = 0;
		Int32 nTotalNumberOfClustersP = 0;
		Int64 nStorageFreeSize = 0;

		//获得目录存储空间情况
		EOS_GetDiskFreeSpace(EOS_GetSpecialPath(EOS_FILE_SPECIAL_PATH_CARD),&nSectorsPerClusterP,&nBytesPerSectorP,  &nNumberOfFreeClustersP,&nTotalNumberOfClustersP);
		//计算可用空间
		nStorageFreeSize = nNumberOfFreeClustersP*nSectorsPerClusterP;
		nStorageFreeSize *= nBytesPerSectorP;
		//单位换算成KB
		nStorageFreeSize /= 1024;
		if(nStorageFreeSize < 4096)
		{
			pApp->MessageBox(TResource::LoadConstString(APP_KA_ID_STRING_SDNotSpace),TResource::LoadConstString(APP_KA_ID_STRING_Info),WMB_OK);
			return -1;		
		}
		
		TUChar ImageFile[EOS_FILE_MAX_PATH] = {0};
		HRESULT hr = 0;

		//UI接口
		TCOM_DigitalCamera_DataType *pCamera = NULL;
		TCOM_SYS_Method_Get *pCameraMethod = NULL;
		TCoInitialize(NULL);
		// 定义数据窗口查找接口
		TCOM_MethodEmun methodEmun(NULL);
		if(methodEmun.EnumMethod( TIID_DigitalCamera_DataType ,0,TIID_SYS_Method_Get)<= 0)  
		{ 
			SS_printf("EnumMethod failed! \n");
			return -1;
		}

		// 获得UI接口
		if(methodEmun.GetDataTypeInterface(0, TCOM_CLSCTX_INPROC_SERVER, (LPVOID *)&pCamera) > 0)  
		{		
			// 获得操作UI接口
			hr = pCamera->QueryInterface(TIID_SYS_Method_Get,( LPVOID * )&pCameraMethod );
			if(!TCOM_S_SUCCESS(hr))
			{
				SS_printf("pCamera->QueryInterface! \n");
			}
		}

		if(pCameraMethod && pCamera)
		{
			// 打开Camera UI接口
			pCamera->SetImageSize(SCR_W, SCR_H);
			pCamera->SetOperationMode(PHOTO_MODE);
			if ( pCameraMethod->Invoke() )
			{
				TUString::StrCopy(ImageFile, pCamera->GetImageFileName ());	  
			}							
			else
			{
			}
		}

		if(pCamera)
		{
			pCamera->Release();
			pCamera = NULL;
		}

		if(pCameraMethod)
		{
			pCameraMethod->Release();
			pCameraMethod = NULL;
		}
		
		TCoFreeUnusedLibraries();
		TCoUninitialize();

		//上传文件
		if (ImageFile != NULL)
			KaiXinAPICommon_PostPhoto(ImageFile, (TUChar*)TResource::LoadConstString(APP_KA_ID_STRING_UploadPhotos), nHwndId);		
	}
	//Select Photo
	else if(nRetPopBoxID == 2)
	{
		// Invoke sample :
		HRESULT      hr;
		TCOM_SYS_Method_Open  *pOpen;
		TCOM_FileBrowser_DataType_FileDialog *pFileDialog;

		TCoInitialize(NULL);

		//查找方法
		TCOM_MethodEmun methodEmun(TResource::LoadConstString(APP_KA_ID_STRING_SelectPhotoAndSend));

		if(methodEmun.EnumMethod(TIID_FileBrowser_DataType_FileDialog, 0, TIID_SYS_Method_Open) <= 0)  // >0 表示找到方法
		{
			TCoUninitialize();
			return -1;
		}
		if(methodEmun.GetDataTypeInterface(0, TCOM_CLSCTX_INPROC_SERVER, (LPVOID *)&pFileDialog) >= 0)
		{
			// 准备数据
			pFileDialog->SetDialogTitle( (TUChar*)TResource::LoadConstString(APP_KA_ID_STRING_UploadPhotos) );
			pFileDialog->SetExtFilter((TUChar*)TResource::LoadConstString(APP_KA_ID_STRING_PhotoFormat)); 
			pFileDialog->SetOpenType(FMB_FILE_SELECT_OPEN_MODE_FILE_OPEN);
			hr = pFileDialog->QueryInterface(TIID_SYS_Method_Open, (LPVOID *)&pOpen);
			if(!TCOM_S_SUCCESS(hr))
			{
				//错误处理
				pFileDialog->Release();
				TCoUninitialize();
				return -1;
			}
			pOpen->Invoke();
			pOpen->Release();

			// 查询用户选择结果 
			if (pFileDialog->GetFilePathName() != NULL)
			{
				KaiXinAPICommon_PostPhoto(pFileDialog->GetFilePathName(), pFileDialog->GetFileTitle(), nHwndId);
			}

			pFileDialog->Release(); // 释放申请的资源
		}
		TCoFreeUnusedLibraries();
		TCoUninitialize();

	}

	return 1;							
}

/**
 * log初始化 
 *
 * \return 
 */
Int32 KaiXin_Log_Init(void)
{
	int iRet = eFailed;
	Handle hFile = NULL;		
	TUChar pszTempPath[EOS_FILE_MAX_PATH] ={0};
	TUChar pszFilePath[EOS_FILE_MAX_PATH] = {0};    // 文件路径 
	
	SS_GetApplicationPath(AppName_App_KaiXin, SS_APP_PATH_TYPE_CACHE, pszFilePath);
	TUString::StrGBToUnicode(pszTempPath,(Char*)"log.txt");
	TUString::StrCat(pszFilePath,pszTempPath);
	
	if (EOS_IsFileExist(pszFilePath))	
		EOS_Delete(pszFilePath);

	return iRet;
}
	
/**
 * log输出 
 *
 * \param logTxt
 *
 * \return 
 */
Int32 KaiXin_Log(char* logTxt)
{
	int iRet = eFailed;
	Handle hFile = NULL;		
	TUChar pszTempPath[EOS_FILE_MAX_PATH] ={0};
	TUChar pszFilePath[EOS_FILE_MAX_PATH] = {0};    // 文件路径 
	
	SS_GetApplicationPath(AppName_App_KaiXin, SS_APP_PATH_TYPE_CACHE, pszFilePath);
	TUString::StrGBToUnicode(pszTempPath,(Char*)"log.txt");
	TUString::StrCat(pszFilePath,pszTempPath);
	
	if (EOS_IsFileExist(pszFilePath))			
		hFile = EOS_Open(pszFilePath, PO_BINARY|PO_RDWR|PO_APPEND, PS_IWRITE);
	else
		hFile = EOS_Open(pszFilePath, PO_TRUNC|PO_BINARY|PO_CREAT|PO_RDWR, PS_IWRITE);
		
	if (hFile < 0)
	{
		return eFailed;
	}	                    		

	EOS_Write(hFile, (void*)logTxt, strlen(logTxt)*sizeof(char));
	EOS_Write(hFile, (void*)"\n", strlen("\n")*sizeof(char));

	EOS_Close(hFile);

	return eSucceed;
}
